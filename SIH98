Problem statement of SIH :

Background: Admissions, fee collection, hostel allocation, and examination records are maintained in separate ledgers. Students queue at multiple counters; staff re-enter identical data; and administrators lack a real-time institutional overview. Description: Comprehensive ERP suites can unify data but remain out of financial reach for many public colleges. Yet much of the required functionality-customised online forms, central data tables, automated receipts, real-time dashboards-already exists in ubiquitous cloud office suites. By intelligently connecting these services, an institution can create a single source of truth without large capital outlay. Essential components include streamlined admission intake, automated fee receipting, live hostel occupancy tracking, and summary dashboards for higher officials. Data security, role-based access and regular back-ups must be baked in from day one. Because staff is already familiar with basic spreadsheet and form tools, the learning curve remains shallow, ensuring broad adoption. Hackathon participants can demonstrate how thoughtful process mapping and lightweight scripting turn an assortment of familiar apps into a cohesive, low-cost ERP that any college can replicate. Expected Solution: Teams should outline an integrated workflow in which admission data flows seamlessly into a central student database, financial transactions automatically generate digital receipts, hostel and library records update the same database in real time, and summary dashboards present key metrics to administrators all delivered through interlinked, widely available software services rather than proprietary or hardware-intensive solutions.


Proposed Soln:

Frontend: React / Next.js, FullCalendar, Intro.js

Backend: Django + DRF or Node.js (Express/Nest)

DB: PostgreSQL

Auth: Keycloak (or Django Allauth + WebAuthn libs)

Object store: MinIO / S3

Payments: Razorpay / Stripe

Docs: Nextcloud or custom module

Dashboards: Metabase / Looker Studio

Chatbot: Rasa / Dialogflow

Face recog: face_recognition (dlib) or DeepFace

2FA/WebAuthn: Keycloak WebAuthn / pyotp

Queue: Celery + Redis

Container: Docker Compose

Hosting: DigitalOcean / AWS Lightsail

 
1) High-level data model & central database

Design principle: one central student record (single source of truth). All modules read/write to this central store.

Core entities:

Student (id, name, email, phone, photo, admission status, roll no, branch, year, badges/points)

Transactions (fee payments, receipts)

HostelAllocation (room_id, start_date, end_date, status)

LibraryRecord (issue/return)

ExamRecord (exam_id, marks, grade)

ResourceBooking (resource_id, timeslot, status)

Documents (doc_id, type, verification_status)

Grievance (id, type, status, assigned_to)

ActivityLedger (activity_id, hours, validation_status)

AuditLog (user, action, timestamp, ip, face_auth_flag)

Central DB choices:

No-code MVP: Google Sheets / Airtable (for small colleges) or Firebase Realtime DB / Firestore.

Self-hosted: PostgreSQL (recommended) or MariaDB.

Structure: use normalized schema in Postgres. Keep an append-only AuditLog table. Store heavy files (PDFs) separately (object storage).

2) Two recommended implementation tracks
Track A — No-/Low-Code MVP (fastest, minimal cost)

Use this if the institution prefers existing cloud office suites and minimal infra:

Forms & intake: Google Forms or Microsoft Forms.

Central DB: Google Sheets + Airtable for richer relations (Airtable has record links). Or Firebase/Firestore for realtime operations.

Automation & integration: Google Apps Script (for Google Workspace) or Power Automate (for Microsoft 365).

Payment integration: Razorpay / Paytm / Stripe (payment gateway webhooks -> Apps Script / Cloud Function).

Receipts: Auto-generate PDF receipts with Apps Script (HTML-to-PDF) and email via Gmail API.

Dashboards: Google Data Studio (Looker Studio) or Microsoft Power BI (free tier), connected to Sheets/Airtable/Firebase.

File storage: Google Drive / OneDrive for documents.

Authentication: Use Google/Microsoft sign-in (OAuth) + enable 2FA via their accounts. For TOTP WebAuthn advanced features, move to Track B later.

Notifications: Email (Gmail/Office365), bulk SMS via local provider (MSG91/TextLocal), or free push via Firebase Cloud Messaging for a basic app.

Helpdesk: Simple FAQ + a chatbot using Dialogflow (connected to website) or a form-based ticketing system (Sheets + automation).

Hosting (if any backend): Use Google Cloud Functions / Firebase Functions (pay-as-you-go).

Why this track: Staff already know Forms/Sheets; no devops; very low upfront cost. Good for pilot within a semester.

Track B — Open-Source Self-Hosted (recommended for scale & privacy)

Use this for a more robust system with advanced features (face recognition on-premise, WebAuthn, RBAC, backups):

Core components

Backend API: Django (Python) or Node.js (Express/NestJS). (I recommend Django for fast admin/ORM and mature auth ecosystem.)

Frontend: React or Next.js (SPA for student/staff portals).

Database: PostgreSQL.

Object storage: MinIO (S3-compatible) or AWS S3 / Wasabi (cheap).

Auth & SSO: Keycloak (open-source) for role-based auth + supports 2FA, social login, and can be extended for WebAuthn.

Dashboards: Metabase (open-source) or Grafana for metrics.

Workflow & automations: Celery (Django) or background workers (Bull/Agenda for Node) for receipts, notifications.

Payments: Razorpay / Stripe integration (server verifies webhook and writes Transaction record).

Document locker: Nextcloud or built-in document module storing file metadata in DB and files in object storage; integrate e-signature via PDFLib / OpenSignature or external eSign providers.

Booking & calendar: Use FullCalendar in frontend with backend endpoints and optimistic locking to prevent double booking.

Chatbot/helpdesk: Rasa (open-source) or Botpress for on-prem chat; integrate with frontend and FAQs.

Search: Elasticsearch or Postgres full-text search for document/records.

Logging & audit: Grafana Loki + Promtail + Grafana, or ELK stack. Keep an append-only AuditLog in DB for compliance.

Containerization: Docker Compose for small setups; Kubernetes for larger (optional).

VPS: DigitalOcean, Linode, or AWS Lightsail (small droplet per college); can run on a single 2-4 vCPU + 4-8GB RAM instance for medium load.

Backup: Automated DB dumps + object storage sync to S3/drive; retain encrypted backups.

3) Module-by-module mapping (step-by-step architecture & tools)
3.1 Admission Intake → Central Student DB

Frontend: React/Next.js or simple Google Form.

Backend endpoint: /api/admissions/create

Flow:

Student fills form (with doc upload).

Backend validates eligibility rule engine (configurable).

Create Student record in Postgres / add row in Airtable.

Trigger seat allocation script (automated or manual approval).

Send email + SMS confirmation and a generated admission token/QR.

Tools:

MVP: Google Forms + Apps Script -> Google Sheets -> Looker Studio.

Prod: React form -> Django API -> Postgres.

3.2 Fee Collection & Auto Receipts

Payment flow:

Student hits payment link (Razorpay/Stripe) created via backend (server-side order creation).

Payment gateway sends webhook to backend.

Backend verifies, creates Transaction record, updates Student.fee_status.

Generate PDF receipt (WeasyPrint / wkhtmltopdf) and email/SMS it.

Tools & libs: Razorpay SDK / Stripe SDK, WeasyPrint, Celery for background PDF generation, SendGrid or SMTP for email.

3.3 Digital Document Locker & e-Verification

Students request documents through a portal.

Flow:

Request created -> status pending.

Staff reviews and attaches scanned document.

System stores file in MinIO/S3, metadata in DB.

For e-verification: Use digital signatures or signed PDF with institution key (or integrate with eSign providers).

Student receives secured link (time-limited, signed URL).

Tools: Nextcloud (if prefer turn-key), or custom module + MinIO + PDF signing library.

3.4 Campus Pulse — Grievance & Feedback Hub

Form/ticket creation with categories & priority.

Routing rules: auto-assign to team based on category.

SLA & status steps visible to admins.

Dashboard: live KPIs (pending, avg resolution time).

Tools: Custom tickets in DB; or integrate open-source helpdesk (Zammad, OTRS).

3.5 Student Skill & Activity Ledger

Record events, workshops, hours, proofs (certificates).

Validation workflow: event organizer or faculty validates participation.

Badges/Points engine:

Simple rules table: activity_type -> points.

Periodic job aggregates points -> award badges (Bronze/Silver/Gold).

Display on student profile and downloadable certificate.

3.6 Smart Resource Booker

Calendar UI (FullCalendar), backend checks for overlapping bookings.

Maintain resource inventory, capacity, dependencies (projector with hall).

Approval workflow for high-priority bookings.

Conflict prevention: optimistic lock + double-check in DB transaction.

3.7 Unified Notification Engine

Message channel abstractions: Email, SMS, Push, WhatsApp (optional paid).

Targeting:

Query central DB with filters (branch/year/hostel/residence/defaulters).

Use templates and variable substitution.

Queue & rate-limiting: use background worker (Celery/RabbitMQ or Bull).

Tools: SMTP + SMS provider (MSG91 / TextLocal), Firebase Cloud Messaging for app push.

3.8 Digital Hostel Pass System

Student creates leave request (with dates) -> Warden approves.

Auto-generate pass (QR code) valid for timeslot.

Entry/exit logging: Gate staff scan QR or use mobile app to mark in/out.

Dashboard: current hostel occupancy, pending leave requests.

3.9 Attendance Gamification (points/badges)

Attendance triggers: daily attendance marking via biometric/fingerprint or manual by staff.

On-time submissions and participations award points.

Badge engine runs nightly; show progress on dashboard.

4) Advanced features & how to implement them
Face recognition for admin logging / advanced logging

Recommendation: keep face recognition on-premise for privacy.

Tools:

Python face_recognition (dlib) or DeepFace for more models.

Capture photo at login time via webcam; compute embedding and compare with stored embeddings.

Use cases:

Admin action logging: store face_match_confidence with AuditLog record.

For higher security, require face verification + password.

Privacy: store only face embeddings (not raw photos) and encrypt them.

2FA + WebAuthn (biometric login via phone)

Implement using WebAuthn (FIDO2) for passwordless + biometric support.

Tools:

Keycloak supports WebAuthn (passkeys) out-of-the-box.

Libraries: webauthn for Python or fido2-lib for Node.

Fallback: TOTP (Google Authenticator) using pyotp.

UX: allow linking phone's biometric (via passkeys) or authenticator app.

Advanced automated helpdesk (guided walkthrough & chatbot)

Guided in-app tours: Intro.js or Shepherd.js for step-by-step UI tours.

Chatbot:

Use Rasa (on-prem) for privacy or Dialogflow for hosted solution.

Integrate bot with a help widget (Botpress or custom).

Connect bot to FAQ/knowledge base and common flows (how to request docs, pay fee).

Escalation: create a ticket if bot fails to resolve.

5) Security, privacy & compliance (must-haves)

RBAC: implement roles (student, faculty, warden, accounts, admin, super-admin). Use Keycloak or Django Groups/Permissions.

Encryption:

At rest: encrypt files in object storage (S3 server-side or client-side encryption).

In transit: enforce TLS everywhere.

Backups: automated DB dumps (daily), S3 sync, retention policy (e.g., 30 days + monthly snapshots).

Audit logs: immutable append-only logs with tamper-evident signatures.

Data minimization: store only required PII. Keep face embeddings instead of raw images if possible.

Consent & policies: student consent for biometric use; publish privacy policy.

6) Deployment, hosting & cost-savers

MVP (Track A): free Google Workspace / basic Airtable; cost mainly for payment gateway and SMS. Minimal hosting.

Prod (Track B):

Host on a single VPS (DigitalOcean / Linode / AWS Lightsail): 2–4 vCPU, 4–8GB RAM (~$20–40/month).

Use Docker Compose for services (web, db, minio, keycloak, redis, celery).

Use Let's Encrypt for TLS.

Cost-saving tips:

Use open-source tools instead of SaaS where possible.

Defer costly channels (WhatsApp Business API) until scale; use email + SMS for critical comms.

Use serverless for low-volume workloads (PDF generation/functions).

7) Minimum Viable Product (MVP) timeline & checklist (what to demo at SIH)

Deliverable for hackathon demo (24–72 hours to build a prototype):

Admission form → creates student record in central DB.

Fee payment simulation → generates receipt PDF and updates student fee status.

Hostel allocation demo (manual or auto) that updates student record.

Simple dashboard (Looker Studio / Metabase) showing admissions, fees, hostel occupancy.

Document request flow: request → staff uploads doc → student receives download link.

Grievance form → ticket created and assigned.

Resource booking UI with conflict prevention.

Notifications (email + SMS stub).

Basic auth + RBAC (student vs staff) and audit log entries shown.

Short video/screenshare showing flow end-to-end.

Optional stretch demo: automated badge issuance for a sample student, and a chatbot answering 3 FAQs.

8) Recommended tech stack (concise)

Frontend: React / Next.js, FullCalendar, Intro.js

Backend: Django + DRF or Node.js (Express/Nest)

DB: PostgreSQL

Auth: Keycloak (or Django Allauth + WebAuthn libs)

Object store: MinIO / S3

Payments: Razorpay / Stripe

Docs: Nextcloud or custom module

Dashboards: Metabase / Looker Studio

Chatbot: Rasa / Dialogflow

Face recog: face_recognition (dlib) or DeepFace

2FA/WebAuthn: Keycloak WebAuthn / pyotp

Queue: Celery + Redis

Container: Docker Compose

Hosting: DigitalOcean / AWS Lightsail

9) Privacy, legal & ethical notes

Collect explicit consent for biometrics (face) and for storing PII.

Allow students to opt-out of face-based features; provide alternative (TOTP).

Rotate keys & secrets; limit admin access.

Maintain a clear data-retention policy.
